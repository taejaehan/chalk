<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Taejae Han | 06. 자율 에이전트 (The nature of code)</title>
  <meta name="description" content="자율 에이전트, 차량과 조향, 조향력, 이동, 도착, 배회, 흐름장 추적, 내적, 경로 추적, 복잡계, 군집 운동(분리, 정렬, 결합), 알고리즘의 효율성, 최적화 방법">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta property="og:title" content="06. 자율 에이전트 (The nature of code)">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://blog.hantaejae.com//posts/06-%EC%9E%90%EC%9C%A8-%EC%97%90%EC%9D%B4%EC%A0%84%ED%8A%B8-the-nature-of-code">
  <meta property="og:description" content="자율 에이전트, 차량과 조향, 조향력, 이동, 도착, 배회, 흐름장 추적, 내적, 경로 추적, 복잡계, 군집 운동(분리, 정렬, 결합), 알고리즘의 효율성, 최적화 방법">
  <meta property="og:site_name" content="Taejae Han">
  <meta property="og:image" content="https://blog.hantaejae.com//assets/og-image.jpg">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:url" content="https://blog.hantaejae.com//posts/06-%EC%9E%90%EC%9C%A8-%EC%97%90%EC%9D%B4%EC%A0%84%ED%8A%B8-the-nature-of-code">
  <meta name="twitter:title" content="06. 자율 에이전트 (The nature of code)">
  <meta name="twitter:description" content="자율 에이전트, 차량과 조향, 조향력, 이동, 도착, 배회, 흐름장 추적, 내적, 경로 추적, 복잡계, 군집 운동(분리, 정렬, 결합), 알고리즘의 효율성, 최적화 방법">
  <meta name="twitter:image" content="https://blog.hantaejae.com//assets/og-image.jpg">

  <link rel="apple-touch-icon" href="/assets/apple-touch-icon.png">
  <link href="https://blog.hantaejae.com//feed.xml" type="application/rss+xml" rel="alternate" title="Taejae Han Last 10 blog posts" />

  
    <link type="text/css" rel="stylesheet" href="/assets/light.css">
  
</head>

<body>
  <main role="main">
    <div class="grid grid-centered">
      <div class="grid-cell">
        <nav class="header-nav reveal">
  <a href="/" class="header-logo" title="Taejae Han">Taejae Han</a>
  <ul class="header-links">
    
      <li>
        <a href="/about" title="About me">
          <span class="icon icon-android-person"></span>
        </a>
      </li>
    
    
    
      <li>
        <a href="https://www.facebook.com/TaejaeHan" target="_blank" title="Facebook">
          <span class="icon icon-social-facebook"></span>
        </a>
      </li>
    
    
      <li>
        <a href="https://github.com/taejaehan" target="_blank" title="GitHub">
          <span class="icon icon-social-github"></span>
        </a>
      </li>
    
    
    
    
    
    
      <li>
        <a href="mailto:hantaejae@gmail.com" title="Email">
          <span class="icon icon-at"></span>
        </a>
      </li>
    
    
  </ul>
</nav>

        <article class="article reveal">
          <header class="article-header">
            <h1>06. 자율 에이전트 (The nature of code)</h1>
            <p>자율 에이전트, 차량과 조향, 조향력, 이동, 도착, 배회, 흐름장 추적, 내적, 경로 추적, 복잡계, 군집 운동(분리, 정렬, 결합), 알고리즘의 효율성, 최적화 방법</p>
            <div class="article-list-footer">
              <span class="article-list-date">
                April 18, 2017
              </span>
              <span class="article-list-divider">-</span>
              <span class="article-list-minutes">
                
                
                  7 minute read
                
              </span>
              <span class="article-list-divider">-</span>
              <div class="article-list-tags">
                
                  <a href="/tag/n-code">n-code</a>
                
                  <a href="/tag/development">development</a>
                
                  <a href="/tag/javascript">javascript</a>
                
              </div>
            </div>
          </header>

          <div class="article-content">
            <h2 id="자율-에이전트autonomous-agent">자율 에이전트(autonomous agent)</h2>
<ul>
  <li>객체들이 각각의 규칙을 가지고 움직이게(희망하고 꿈꾸고 두려워하게) 할 수 있는 운동.</li>
  <li>계획된 환경에 의해서 영향을 받는 것이 아니라, <b style="color:black">스스로</b>가 환경 내부에서 어떤 행동을 할 지 결정하는 객체</li>
</ul>

<ol>
  <li>자율 에이전트에는 주변 환경을 인식하는 한정된 능력이 있습니다.</li>
  <li>자율 에이전트는 주변 환경으로부터 얻은 정보를 처리하고 행동을 연산합니다.</li>
  <li>자율 에이전트는 리더(Leader)라는 개념이 없습니다.</li>
</ol>

<h2 id="차량과-조향">차량과 조향</h2>
<ul>
  <li>레이놀즈(Reynolds)는 자율 에이전트를 설명할 떄 차량(Vehicle)이라는 용어를 사용했습니다.</li>
  <li>이상적인 차량의 운동을 행동선택, 조향, 이동운동이는 3가지 계층으로 나누어 설명했습니다.
    <ol>
      <li>행동선택 : (1개 또는 여러개) 차량은 목적을 가지고, 그 목적을 기반으로 (1개 또는 여러개) 행동을 선택 할 수 있습니다. 
차량은 목적(욕구)에 기반한 행동을 연산하는데 목적지를 찾거나, 장애물을 피하거나, 경로를 따라 움직이는 등 여러개의 목적과 행동이 있습니다.</li>
      <li>조향 : 차량이 어떠한 행동을 할 지 선택했다면 움직임과 관련된 연산을 수행합니다.<br /></li>
      <li>이동운동 : 대부분의 경우에는 3번은 무시합니다. 하지만 양발을 움직이거나, 바퀴가 구르거나, 페달이 돌아가거나, 움직였던 흔적을 남기는 등의 기능을 추가 할 수 있습니다.</li>
    </ol>
  </li>
</ul>

<h2 id="조향력-이동">조향력, 이동</h2>

<ul>
  <li>2장에서 나왔던데로 Attractor로 객체를 만들어 차량을 끌어당길 수도 있지만, 스스로 상태와 환경을 인식하고 이를 기반으로 목표를 향해 조향(속도를 결정)하는 것이 이번 장의 목표.</li>
  <li><b style="color:black">조향력 = 원하는 속도 - 현재속도</b></li>
  <li>현재속도는 설정하기 나름입니다.(0이거나 전에 속도를 이어받아 사용합니다.)</li>
  <li>원하는 속도는 원하는 타켓의 위치벡터에서 현재 차량의 위치벡터를 빼주면 되는데 한번에 해당 속도를 더해주면 타겟위치로 바로 이동하게 됩니다.</li>
  <li>따라서 최대 속력을 설정해서 원하는 속도의 단위벡터값에 곱해주어 해당 타겟으로 이동시킵니다.</li>
  <li>현재 속도가 0이라면 원하는 속도가 곧 조향력이 될 수 도 있지만 대부분 차량은 스스로의 속도를 인식하고 이에 따라 계속해서 다른 조향력을 적용합니다.</li>
  <li>조향력의 최대값(최대 힘)을 설정하여 한번에 더해주는 힘을 제한해주면 보다 다양한 시뮬레이션을 할 수 있습니다.</li>
  <li>최대 힘이 클수록 직석으로 이동하게 되고 작을수록 곡선으로 이동하게 됩니다.</li>
</ul>

<h2 id="도착">도착</h2>
<ul>
  <li>타겟에 도착할 때 멈추게 하려면 타겟주위에 원을 그리고, 그 원안에 들어갈 경우 속도를 최대속도부터 0까지 조절합니다.</li>
  <li>2장에서 배웠던 중력은 힘의 걍약에 상관없이 객체는 항상 목표를 향해 일정한 속도로 끌려가지만, 조향기능을 사용하면 현재 속도와 필요한 속도의 차이를 기반으로 계산하여 오차를 기반으로 속도를 계산하여 보다 살아있는 물체처럼 행동합니다.</li>
</ul>

<h2 id="배회">배회</h2>
<ul>
  <li>우리가 원하는 것은 필요한 속도라는 벡터를 찾아내는 방법을 배우고, 이를 기반으로 객체가 스스로 조향행동을 만들게 하는 것입니다.</li>
  <li>배회는 어느정도 긴 시간동안 임의 상태를 가지는 조향으로, 특정한 시점에서 조향 방향은 다음 시점의 조향 방향과 관계를 가진다. 간단하게 각 시점에서 임의 조향 방향을 생성하기만 해도 흥미롭고 재미있는 움직임이 만들어진다.(크레이그 레이놀즈)</li>
  <li>예를들어 차량이 미래의 위치를 기준으로 원을 하나 그리고 그 원위에서 임의의 점을 생성하여 그 점이 목표지점이 되어 차량을 조향하는 방법이 있다. 이러한 랜덤한 점을 원으로 한정하여 마구잡이로 보이지 않게 할 수 있다. 이러한 임의성을 현실의 움직임에서 영감을 얻어 동작을 구현하는 것이 핵심입니다.</li>
  <li>다른 예로, 벽의 내부에서 벗어나지 않게 하려면 벽과 일정거리만큼 가까워지면 반대 방향으로 움직이게 해줄 수 있습니다.</li>
</ul>

<h2 id="흐름장-추적">흐름장 추적</h2>
<ul>
  <li>흐름장이란 화면을 격자 모양으로 나누고 각 칸에 방향을 나타내는 화살표(벡터)를 그려주고, 차량이 어떤 칸에 들어가면 해당 벡터를 따라 (원하는 속도로) 조향하는 것입니다.</li>
  <li>각 칸의 화살표는 한쪽으로 향하거나, 랜덤하거나, 가운데로 몰리거나, 펄린 노이즈를 사용 할 수 도 있습니다.</li>
  <li>차량이 어떤 칸에 들어 갔을 때 해당 칸의 화살표(벡터)를 구하고 원하는 속도를 곱해 ‘원하는 속도’를 만든 후 현재 속도를 빼서 조향력을 구해 움직입니다.</li>
</ul>

<h2 id="내적">내적</h2>
<ul>
  <li>벡터는 특정 상태에서 사용할 수 있는 곱셈과 비슷한 연산인 내적이 있습니다.</li>
  <li><b style="color:black">AB벡터의 내적 = A.x * B.x + A.y * B.y</b></li>
  <li>내적의 결과는 스칼라(단일 값)이 됩니다.</li>
  <li>한편 내적은 2개의 벡터 사이의 각도를 구하는 데 일반적으로 사용되어, 아래와 같이도 구할 수 있습니다.</li>
  <li>
    <p><b style="color:black">AB벡터의 내적 = A크기 * B크기 * cos(theta)</b></p>
  </li>
  <li>따라서,</li>
  <li><b style="color:black">A.x * B.x + A.y * B.y = A크기 * B크기 * cos(theta)</b></li>
  <li><b style="color:black">cos(theta) = (A.x * B.x + A.y * B.y) / (A크기 * B크기)</b></li>
  <li>
    <p><b style="color:black">theta = acos( (A.x * B.x + A.y * B.y) / (A크기 * B크기) )</b></p>
  </li>
  <li>2개의 벡터가 수직하는 경우 내적은 0이 됩니다. <br />
( ‘AB벡터의 내적 = A크기 * B크기 * cos(theta)’ 에서 cos(90)은 0 이므로 )</li>
  <li>2개의 벡터가 단위벡터라면 내적은 둘 사이의 각도를 코사인한 값이 됩니다. <br />
( ‘AB벡터의 내적 = A크기 * B크기 * cos(theta)’ 에서 A크기 * B크기는 1이므로 ‘AB벡터의 내적 = cos(theta)’ )</li>
</ul>

<h2 id="경로-추적">경로 추적</h2>
<ul>
  <li>경로 탐색은 두 점사이의 최단거리를 구하는 인공지능 연구학문이고 여기서 살펴볼 것은 이미 존재하고 있는 경로를 따라 차량이 움직이게 만드는 경로추적 입니다.</li>
  <li>경로는 점의 집합이라고 정의하고, 경로의 너비는 경로의 크기를 의미합니다. 너비가 작을 수록 차량은 객체 선 중심에 더 가깝게 이동하고 반대면 선의 중심에서 조금 떨어져서 이동하기도 할 것 입니다.</li>
  <li>차량의 속도를 정규화하고 원하는 속도를 곱하여 미래 위치를 예측합니다.</li>
  <li>계산된 미래위치에서 경로까지의 거리를 구합니다. 만약 거리가 경로의 너비보다 크다면 경로를 벗어난 것이고, 너비보다 작다면 잘 움직이고 있다는 것 입니다.</li>
  <li>
    <p>점과 선 사이의 거리는 점과 선을 잇는 법선의 길이로 정의 합니다.(법선은 특정한 점과 특정한 선에 수직으로 위치하는 직선을 의미합니다)</p>
  </li>
  <li>경로의 시작점과 미래위치를 이어서 벡터A라고 하고, 경로의 시작점과 끝점을 이어 벡터B라 하고, 경로의 시작점으로 부터 법선의 점까지 거리는 c라고 하자.</li>
  <li>c = A크기 * cos(theta)</li>
  <li>theta를 구하면 법선의 점을 정의 할 수 있다. <br />
(theta =  acos( (A.x * B.x + A.y * B.y) / (A크기 * B크기))</li>
  <li>B를 단위벡터와 시켜주고 c만큼 곱해준 값을 경로의 시작점에 더해주면 법선의 점 위치를 구할 수 있다.</li>
  <li>
    <p>법선의점의위치 = [ (B단위벡터 * c).x + start.x , (B단위벡터 * c).y + start.y ]</p>
  </li>
  <li>내적을 공부하면서 살펴보았던 ‘AB벡터의 내적 = A크기 * B크기 * cos(theta)’에서 B가 단위벡터라면</li>
  <li><b style="color:black">AB벡터의 내적 = A크기 * cos(theta) </b></li>
  <li>위에서 보았던 c와 AB벡터의 내적이 같아지는 결과다. 그렇다면 이제 그냥 B벡터를 정규화(단위벡터화) 해버리면 된다.</li>
  <li><b style="color:black">법선의점의위치 = [ (B단위벡터 * AB벡터의 내적).x + start.x , (B단위벡터 * AB벡터의 내적).y + start.y ]</b></li>
  <li>
    <p>이러한 과정을 스칼라 투영이라고 합니다. <b style="color:black">‘A크기 * cos(theta)’는 B위에 스칼라 투영한 결과</b>라고 합니다.</p>
  </li>
  <li>법선 점의 위치를 알았다면 차량을 조향할 수 있는데, 법선점과 예측된 미래 위치사이의 거리가 경로의 너비보다 큰경우만 경로를 향해 조향합니다.</li>
  <li>목표(타겟)를 경로위에 있는 법선으로 해도되고 레이놀즈 알고리즘처럼 경로보다 조금 앞에 해도 됩니다.</li>
  <li>
    <p>B벡터를 정규화하고 원하는 만큼 곱해주고 법선의점에 더해줍니다.</p>
  </li>
  <li>여러개의 선분이 있는 경로를 추적하기 위해서는 여러선분의 각 법선을 구한 후 가장 가까운 선분위에 있는 법선 점을 선택하게 합니다.</li>
  <li>차량이 어떤 선분을 지나간 경우 해당 선분위에 없는 점이 법선 점이 될 수 있는데, 그런 경우는 지나간 선분의 마지막 지점의 점을 법선으로 생각하고 계산해 줍니다.</li>
</ul>

<h2 id="복잡계">복잡계</h2>
<ul>
  <li>하나의 객체가 아니라 다른 대상과 서로 상화작용하는 객체 시스템.</li>
  <li>복잡계라는 것은 다수의 대상이 합쳐져 단순한 연산 이상의 기능을 발휘하는 계(시스템)이라고 정의함.</li>
  <li>각각의 행동은 매우 단순하지만 모여 계를 이루면 전체적인 행동이 굉장히 복잡해지고 지적이며 예상하기 힘들게 됩니다. 중요한 원리는 3가지.
    <ol>
      <li>여러 개의 단순한 개체가 좁은 공간 안에 존재.</li>
      <li>단순한 개체들이 병렬적으로 동작. (draw()함수안 반복문에서 어떻게 움직일지 결정해게 만들면 병렬적으로 동작하는 것처럼 보입니다)</li>
      <li>시스템 전체에서 창조적인 현상이 발생. 서로 상호작용하면서 복잡한 행동, 패턴, 지성이 생겨납니다.</li>
    </ol>
  </li>
  <li>복잡계는 다음과 같은 3가지 특징이 있습니다. (모든 복잡계가 이러한 특성을 갖지는 않습니다)
    <ol>
      <li>비선형성 : 일명 나비효과라고 불리는 것으로 초기값 상태가 아주 미세하게 변화해도 최정적인 결과는 전혀 상관없이(선형적이지 않게) 나오므로, 이를 비선형이라고 부릅니다. 비선형성은 카오스 계의 상위 집합입니다.</li>
      <li>경쟁과 협력 : 정렬,결합, 분리라는 3가지 규칙을 사용합니다. 정렬과 결합은 협력(서로 모이는 욕구), 반대로 분리는 서로가 멀어지는 욕구 경쟁과 협력은 생명체로 구성된 복잡계에서는 자주 볼 수 있는 현상이지만, 날씨 등의 비생명계로 구성된 복잡계에서는 찾아볼 수 없는 현상입니다.</li>
      <li>피드백 : 대부분의 복잡계는 피드백이 반복됩니다. 대부분의 경제모델(수요와공급, 주식시장 등), 유행, 선거, 군중, 교통의 흐름 등 모두 복잡계에서 일어나는 현상.</li>
    </ol>
  </li>
</ul>

<h2 id="군집활동">군집활동</h2>
<ul>
  <li>여러개의 차량을 만든 후 행동을 조작합니다. 마우스를 따라 움직이게 하면서 다른 차량에게서는 멀어지도록(분리) 합니다.</li>
  <li>분리는 ‘밀집을 피하기 위한 조향’으로 탐색(타겟을 향해움직이던 것)을 반대로 만들면 분리 행동이 됩니다.</li>
  <li>1개 이상의 차량이 한꺼번에 가까워지려고 하면 각각의 인접 차량으로부터 회피를 위한 벡터를 만들고 모든 것의 평균을 내서 분리합니다.</li>
  <li>인접한 거리를 비교할 경우 0보다 크다라는 조건을 넣어 자기 자신과는 비교하지 못하도록 합니다.</li>
  <li>
    <p>마우스를 따라가고, 회피하는 함수에서 힘을 바로 적용하지 말고 리턴받아 하나의 함수에서 적용하여 시간,차량,조건에 따라 힘의 크기를 변경 해 줍니다.</p>
  </li>
  <li>군집은 새, 어류, 곤충등에서 자주 볼 수 있는 특징으로 동물들이 모여 만들어지는 집단을 의미합니다.</li>
  <li>레이놀즈는 보이드(bird-like object)라는 용어로 각 요소를 표현했습니다.</li>
  <li>군집의 규칙은 3가지
    <ol>
      <li>분리 : 회피라고도 부르며, 이웃한 대상과 충돌을 피하려는 조향</li>
      <li>정렬 : 복사라고도 부르며, 이웃한 대상과 같은 방향으로 조향</li>
      <li>결합 : 집중이라고도 부르며, 이웃한 대상들의 중심을 향해 조향(집단을 유지하려는 성질)</li>
    </ol>
  </li>
  <li>좁은영역에서만 서로 상호작용해야 한다는 복잡계의 배경원리에 따라 인접한 보이드의 정보만 알 수 있도록 설정합니다.</li>
  <li>분리는 위에 설명했던 것과 같고, 정렬은 이웃한 대상과 같은 방향으로 조향합니다. 이때 보이드의 원하는 속도는 이웃한 대상들의 평균 속도가 됩니다.</li>
  <li>결합부분은 정렬시 다른 보이드의 평균속도를 연산하는 부분을 찾아, 인전합 보이드의 평균 위치를 연산하도록 바꾸고, 해당 평균위치를 추적하게 만들어 줍니다.</li>
</ul>

<h2 id="알고리즘의-효율성-최적화-방법">알고리즘의 효율성, 최적화 방법</h2>
<ul>
  <li>컴퓨터 과학자들은 빅오표기(Big O Notation)라는 방법으로 알고리즘을 분석합니다. 이는 알고리즘의 효율석, 즉 모든 것을 실행하는 데 얼마나 많은 자원(시간 또는 메모리)을 사용하는지를 나타냅니다.</li>
  <li>
    <p>화면 전체 보이드와 전부 상화작용한다면 연산이 너무 많습니다. 화면을 격자로 나눠서 해당 칸의(엄밀히 말하면 주변에 있는 8칸도) 보이드만 연산한다면 부하를 줄일 수 있습니다. 이 방법은 ‘바이너리 라티스 공간 세분할’이라고 부릅니다. 물론 한칸에 모두 모여버리면 전체를 다 확인해야 합니다. 이러한 방법도 해결 할 수 있지만 다루지 않습니다. 해결 방법으로는 toxiclib의 Octree예제를 살펴보시기 바랍니다.</p>
  </li>
  <li>크기의 제곱(또는 길이의 제곱)에서 제곱근을 빼고 연산하면 코드의 속도를 빠르게 만들 수 있습니다. 한두개가 아니라 몇천개라면 속도가 향상됨을 느낄 수 있습니다.</li>
  <li>사인과 코사인 룩업 테이블. 일반적으로 제곱근, 사인, 코사인, 탄젠트 등의 함수는 계산하는 데 시간이 걸리는 함수 입니다. 매번 호출해서 계산하기 보다는 사인, 코사인의 0부터 TWO_PI까지의 값을 계산한 배열을 만들고 값을 저장해서 필요할 때 마다 꺼내어 사용하면 됩니다.</li>
  <li>불필요한 PVector객체 생성를 막아야 합니다. 예를 들어 mouse위치를 가져오는 벡터를 for문안에 사용하는 것을 피해야 하고, 바로 연산이 가능한 벡터를 따로 변수로 만드는 것을 줄여야 합니다.</li>
</ul>


          </div>

          <div class="article-share">
            
            <a href="" title="Share on Twitter" onclick="window.open('https://twitter.com/home?status=06. 자율 에이전트 (The nature of code) - https://blog.hantaejae.com//posts/06-%EC%9E%90%EC%9C%A8-%EC%97%90%EC%9D%B4%EC%A0%84%ED%8A%B8-the-nature-of-code ', 'newwindow', 'width=500, height=225'); return false;">
              <span class="icon icon-social-twitter"></span>
            </a>
            <a href="" title="Share on Facebook" onclick="window.open('https://www.facebook.com/sharer/sharer.php?u=https://blog.hantaejae.com//posts/06-%EC%9E%90%EC%9C%A8-%EC%97%90%EC%9D%B4%EC%A0%84%ED%8A%B8-the-nature-of-code', 'newwindow', 'width=500, height=500'); return false;">
              <span class="icon icon-social-facebook"></span>
            </a>
            <a href="" title="Share on Google+" onclick="window.open('https://plus.google.com/share?url=https://blog.hantaejae.com//posts/06-%EC%9E%90%EC%9C%A8-%EC%97%90%EC%9D%B4%EC%A0%84%ED%8A%B8-the-nature-of-code', 'newwindow', 'width=550, height=400'); return false;">
              <span class="icon icon-social-googleplus"></span>
            </a>
          </div>

          
        </article>
        <footer class="footer reveal">
  <p>
    2019 blog by <a href="/about" title="About me">Taejae Han</a>
    <!-- Download it <a href="https://github.com/nielsenramon/chalk" target="_blank" title="Download Chalk">here</a>. -->
  </p>
</footer>

      </div>
    </div>
  </main>
  <script type="text/javascript" src="/assets/vendor.js"></script>
<script type="text/javascript" src="/assets/application.js"></script>

<script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.16/webfont.js"></script>
<script>
  WebFont.load({
    google: {
      families: ['Cormorant Garamond:700', 'Lato:300,400,700']
    }
  });
</script>


  <script>
    window.ga=function(){ga.q.push(arguments)};ga.q=[];ga.l=+new Date;
    ga('create','UA-90155456-1','auto');ga('send','pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>


</body>
</html>
