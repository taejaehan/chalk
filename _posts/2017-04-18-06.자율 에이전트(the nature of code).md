---
layout: post
title: "06. 자율 에이전트 (The nature of code)"
description: "자율 에이전트, 차량과 조향, 조향력, 이동, 도착, 배회, 흐름장 추적, 내적, 경로 추적, 복잡계, 군집 운동(분리, 정렬, 결합), 알고리즘의 효율성, 최적화 방법"
tags: [n-code, development, javascript]
---

## 자율 에이전트(autonomous agent)
- 객체들이 각각의 규칙을 가지고 움직이게(희망하고 꿈꾸고 두려워하게) 할 수 있는 운동.
- 계획된 환경에 의해서 영향을 받는 것이 아니라, <b style="color:black">스스로</b>가 환경 내부에서 어떤 행동을 할 지 결정하는 객체

1. 자율 에이전트에는 주변 환경을 인식하는 한정된 능력이 있습니다.
2. 자율 에이전트는 주변 환경으로부터 얻은 정보를 처리하고 행동을 연산합니다.
3. 자율 에이전트는 리더(Leader)라는 개념이 없습니다.

## 차량과 조향
- 레이놀즈(Reynolds)는 자율 에이전트를 설명할 떄 차량(Vehicle)이라는 용어를 사용했습니다.
- 이상적인 차량의 운동을 행동선택, 조향, 이동운동이는 3가지 계층으로 나누어 설명했습니다.
1. 행동선택 : (1개 또는 여러개) 차량은 목적을 가지고, 그 목적을 기반으로 (1개 또는 여러개) 행동을 선택 할 수 있습니다. 
차량은 목적(욕구)에 기반한 행동을 연산하는데 목적지를 찾거나, 장애물을 피하거나, 경로를 따라 움직이는 등 여러개의 목적과 행동이 있습니다. 
2. 조향 : 차량이 어떠한 행동을 할 지 선택했다면 움직임과 관련된 연산을 수행합니다.<br>
3. 이동운동 : 대부분의 경우에는 3번은 무시합니다. 하지만 양발을 움직이거나, 바퀴가 구르거나, 페달이 돌아가거나, 움직였던 흔적을 남기는 등의 기능을 추가 할 수 있습니다.

## 조향력, 이동

- 2장에서 나왔던데로 Attractor로 객체를 만들어 차량을 끌어당길 수도 있지만, 스스로 상태와 환경을 인식하고 이를 기반으로 목표를 향해 조향(속도를 결정)하는 것이 이번 장의 목표.
- <b style="color:black">조향력 = 원하는 속도 - 현재속도</b>
- 현재속도는 설정하기 나름입니다.(0이거나 전에 속도를 이어받아 사용합니다.)
- 원하는 속도는 원하는 타켓의 위치벡터에서 현재 차량의 위치벡터를 빼주면 되는데 한번에 해당 속도를 더해주면 타겟위치로 바로 이동하게 됩니다.
- 따라서 최대 속력을 설정해서 원하는 속도의 단위벡터값에 곱해주어 해당 타겟으로 이동시킵니다.
- 현재 속도가 0이라면 원하는 속도가 곧 조향력이 될 수 도 있지만 대부분 차량은 스스로의 속도를 인식하고 이에 따라 계속해서 다른 조향력을 적용합니다.
- 조향력의 최대값(최대 힘)을 설정하여 한번에 더해주는 힘을 제한해주면 보다 다양한 시뮬레이션을 할 수 있습니다.
- 최대 힘이 클수록 직석으로 이동하게 되고 작을수록 곡선으로 이동하게 됩니다.

## 도착
- 타겟에 도착할 때 멈추게 하려면 타겟주위에 원을 그리고, 그 원안에 들어갈 경우 속도를 최대속도부터 0까지 조절합니다.
- 2장에서 배웠던 중력은 힘의 걍약에 상관없이 객체는 항상 목표를 향해 일정한 속도로 끌려가지만, 조향기능을 사용하면 현재 속도와 필요한 속도의 차이를 기반으로 계산하여 오차를 기반으로 속도를 계산하여 보다 살아있는 물체처럼 행동합니다.

## 배회
- 우리가 원하는 것은 필요한 속도라는 벡터를 찾아내는 방법을 배우고, 이를 기반으로 객체가 스스로 조향행동을 만들게 하는 것입니다.
- 배회는 어느정도 긴 시간동안 임의 상태를 가지는 조향으로, 특정한 시점에서 조향 방향은 다음 시점의 조향 방향과 관계를 가진다. 간단하게 각 시점에서 임의 조향 방향을 생성하기만 해도 흥미롭고 재미있는 움직임이 만들어진다.(크레이그 레이놀즈)
- 예를들어 차량이 미래의 위치를 기준으로 원을 하나 그리고 그 원위에서 임의의 점을 생성하여 그 점이 목표지점이 되어 차량을 조향하는 방법이 있다. 이러한 랜덤한 점을 원으로 한정하여 마구잡이로 보이지 않게 할 수 있다. 이러한 임의성을 현실의 움직임에서 영감을 얻어 동작을 구현하는 것이 핵심입니다.
- 다른 예로, 벽의 내부에서 벗어나지 않게 하려면 벽과 일정거리만큼 가까워지면 반대 방향으로 움직이게 해줄 수 있습니다.

## 흐름장 추적
- 흐름장이란 화면을 격자 모양으로 나누고 각 칸에 방향을 나타내는 화살표(벡터)를 그려주고, 차량이 어떤 칸에 들어가면 해당 벡터를 따라 (원하는 속도로) 조향하는 것입니다.
- 각 칸의 화살표는 한쪽으로 향하거나, 랜덤하거나, 가운데로 몰리거나, 펄린 노이즈를 사용 할 수 도 있습니다.
- 차량이 어떤 칸에 들어 갔을 때 해당 칸의 화살표(벡터)를 구하고 원하는 속도를 곱해 '원하는 속도'를 만든 후 현재 속도를 빼서 조향력을 구해 움직입니다.

## 내적
- 벡터는 특정 상태에서 사용할 수 있는 곱셈과 비슷한 연산인 내적이 있습니다.
- <b style="color:black">AB벡터의 내적 = A.x * B.x + A.y * B.y</b>
- 내적의 결과는 스칼라(단일 값)이 됩니다.
- 한편 내적은 2개의 벡터 사이의 각도를 구하는 데 일반적으로 사용되어, 아래와 같이도 구할 수 있습니다.
- <b style="color:black">AB벡터의 내적 = A크기 * B크기 * cos(theta)</b>

- 따라서,
- <b style="color:black">A.x * B.x + A.y * B.y = A크기 * B크기 * cos(theta)</b>
- <b style="color:black">cos(theta) = (A.x * B.x + A.y * B.y) / (A크기 * B크기)</b>
- <b style="color:black">theta = acos( (A.x * B.x + A.y * B.y) / (A크기 * B크기) )</b>

- 2개의 벡터가 수직하는 경우 내적은 0이 됩니다. <br>
( 'AB벡터의 내적 = A크기 * B크기 * cos(theta)' 에서 cos(90)은 0 이므로 )
- 2개의 벡터가 단위벡터라면 내적은 둘 사이의 각도를 코사인한 값이 됩니다. <br>
( 'AB벡터의 내적 = A크기 * B크기 * cos(theta)' 에서 A크기 * B크기는 1이므로 'AB벡터의 내적 = cos(theta)' )

## 경로 추적
- 경로 탐색은 두 점사이의 최단거리를 구하는 인공지능 연구학문이고 여기서 살펴볼 것은 이미 존재하고 있는 경로를 따라 차량이 움직이게 만드는 경로추적 입니다.
- 경로는 점의 집합이라고 정의하고, 경로의 너비는 경로의 크기를 의미합니다. 너비가 작을 수록 차량은 객체 선 중심에 더 가깝게 이동하고 반대면 선의 중심에서 조금 떨어져서 이동하기도 할 것 입니다.
- 차량의 속도를 정규화하고 원하는 속도를 곱하여 미래 위치를 예측합니다.
- 계산된 미래위치에서 경로까지의 거리를 구합니다. 만약 거리가 경로의 너비보다 크다면 경로를 벗어난 것이고, 너비보다 작다면 잘 움직이고 있다는 것 입니다.
- 점과 선 사이의 거리는 점과 선을 잇는 법선의 길이로 정의 합니다.(법선은 특정한 점과 특정한 선에 수직으로 위치하는 직선을 의미합니다)

- 경로의 시작점과 미래위치를 이어서 벡터A라고 하고, 경로의 시작점과 끝점을 이어 벡터B라 하고, 경로의 시작점으로 부터 법선의 점까지 거리는 c라고 하자.
- c = A크기 * cos(theta)
- theta를 구하면 법선의 점을 정의 할 수 있다. <br>
(theta =  acos( (A.x * B.x + A.y * B.y) / (A크기 * B크기))
- B를 단위벡터와 시켜주고 c만큼 곱해준 값을 경로의 시작점에 더해주면 법선의 점 위치를 구할 수 있다.
- 법선의점의위치 = [ (B단위벡터 * c).x + start.x , (B단위벡터 * c).y + start.y ]

- 내적을 공부하면서 살펴보았던 'AB벡터의 내적 = A크기 * B크기 * cos(theta)'에서 B가 단위벡터라면
- <b style="color:black">AB벡터의 내적 = A크기 * cos(theta) </b>
- 위에서 보았던 c와 AB벡터의 내적이 같아지는 결과다. 그렇다면 이제 그냥 B벡터를 정규화(단위벡터화) 해버리면 된다.
- <b style="color:black">법선의점의위치 = [ (B단위벡터 * AB벡터의 내적).x + start.x , (B단위벡터 * AB벡터의 내적).y + start.y ]</b>
- 이러한 과정을 스칼라 투영이라고 합니다. <b style="color:black">'A크기 * cos(theta)'는 B위에 스칼라 투영한 결과</b>라고 합니다.

- 법선 점의 위치를 알았다면 차량을 조향할 수 있는데, 법선점과 예측된 미래 위치사이의 거리가 경로의 너비보다 큰경우만 경로를 향해 조향합니다.
- 목표(타겟)를 경로위에 있는 법선으로 해도되고 레이놀즈 알고리즘처럼 경로보다 조금 앞에 해도 됩니다.
- B벡터를 정규화하고 원하는 만큼 곱해주고 법선의점에 더해줍니다.

- 여러개의 선분이 있는 경로를 추적하기 위해서는 여러선분의 각 법선을 구한 후 가장 가까운 선분위에 있는 법선 점을 선택하게 합니다.
- 차량이 어떤 선분을 지나간 경우 해당 선분위에 없는 점이 법선 점이 될 수 있는데, 그런 경우는 지나간 선분의 마지막 지점의 점을 법선으로 생각하고 계산해 줍니다.


## 복잡계
- 하나의 객체가 아니라 다른 대상과 서로 상화작용하는 객체 시스템.
- 복잡계라는 것은 다수의 대상이 합쳐져 단순한 연산 이상의 기능을 발휘하는 계(시스템)이라고 정의함.
- 각각의 행동은 매우 단순하지만 모여 계를 이루면 전체적인 행동이 굉장히 복잡해지고 지적이며 예상하기 힘들게 됩니다. 중요한 원리는 3가지.
1. 여러 개의 단순한 개체가 좁은 공간 안에 존재.
2. 단순한 개체들이 병렬적으로 동작. (draw()함수안 반복문에서 어떻게 움직일지 결정해게 만들면 병렬적으로 동작하는 것처럼 보입니다)
3. 시스템 전체에서 창조적인 현상이 발생. 서로 상호작용하면서 복잡한 행동, 패턴, 지성이 생겨납니다.

- 복잡계는 다음과 같은 3가지 특징이 있습니다. (모든 복잡계가 이러한 특성을 갖지는 않습니다)
1. 비선형성 : 일명 나비효과라고 불리는 것으로 초기값 상태가 아주 미세하게 변화해도 최정적인 결과는 전혀 상관없이(선형적이지 않게) 나오므로, 이를 비선형이라고 부릅니다. 비선형성은 카오스 계의 상위 집합입니다.
2. 경쟁과 협력 : 정렬,결합, 분리라는 3가지 규칙을 사용합니다. 정렬과 결합은 협력(서로 모이는 욕구), 반대로 분리는 서로가 멀어지는 욕구 경쟁과 협력은 생명체로 구성된 복잡계에서는 자주 볼 수 있는 현상이지만, 날씨 등의 비생명계로 구성된 복잡계에서는 찾아볼 수 없는 현상입니다.
3. 피드백 : 대부분의 복잡계는 피드백이 반복됩니다. 대부분의 경제모델(수요와공급, 주식시장 등), 유행, 선거, 군중, 교통의 흐름 등 모두 복잡계에서 일어나는 현상.

## 군집활동
- 여러개의 차량을 만든 후 행동을 조작합니다. 마우스를 따라 움직이게 하면서 다른 차량에게서는 멀어지도록(분리) 합니다.
- 분리는 '밀집을 피하기 위한 조향'으로 탐색(타겟을 향해움직이던 것)을 반대로 만들면 분리 행동이 됩니다.
- 1개 이상의 차량이 한꺼번에 가까워지려고 하면 각각의 인접 차량으로부터 회피를 위한 벡터를 만들고 모든 것의 평균을 내서 분리합니다.
- 인접한 거리를 비교할 경우 0보다 크다라는 조건을 넣어 자기 자신과는 비교하지 못하도록 합니다.
- 마우스를 따라가고, 회피하는 함수에서 힘을 바로 적용하지 말고 리턴받아 하나의 함수에서 적용하여 시간,차량,조건에 따라 힘의 크기를 변경 해 줍니다.

- 군집은 새, 어류, 곤충등에서 자주 볼 수 있는 특징으로 동물들이 모여 만들어지는 집단을 의미합니다.
- 레이놀즈는 보이드(bird-like object)라는 용어로 각 요소를 표현했습니다.
- 군집의 규칙은 3가지
1. 분리 : 회피라고도 부르며, 이웃한 대상과 충돌을 피하려는 조향
2. 정렬 : 복사라고도 부르며, 이웃한 대상과 같은 방향으로 조향
3. 결합 : 집중이라고도 부르며, 이웃한 대상들의 중심을 향해 조향(집단을 유지하려는 성질) 
- 좁은영역에서만 서로 상호작용해야 한다는 복잡계의 배경원리에 따라 인접한 보이드의 정보만 알 수 있도록 설정합니다.
- 분리는 위에 설명했던 것과 같고, 정렬은 이웃한 대상과 같은 방향으로 조향합니다. 이때 보이드의 원하는 속도는 이웃한 대상들의 평균 속도가 됩니다.
- 결합부분은 정렬시 다른 보이드의 평균속도를 연산하는 부분을 찾아, 인전합 보이드의 평균 위치를 연산하도록 바꾸고, 해당 평균위치를 추적하게 만들어 줍니다.

## 알고리즘의 효율성, 최적화 방법
- 컴퓨터 과학자들은 빅오표기(Big O Notation)라는 방법으로 알고리즘을 분석합니다. 이는 알고리즘의 효율석, 즉 모든 것을 실행하는 데 얼마나 많은 자원(시간 또는 메모리)을 사용하는지를 나타냅니다.
- 화면 전체 보이드와 전부 상화작용한다면 연산이 너무 많습니다. 화면을 격자로 나눠서 해당 칸의(엄밀히 말하면 주변에 있는 8칸도) 보이드만 연산한다면 부하를 줄일 수 있습니다. 이 방법은 '바이너리 라티스 공간 세분할'이라고 부릅니다. 물론 한칸에 모두 모여버리면 전체를 다 확인해야 합니다. 이러한 방법도 해결 할 수 있지만 다루지 않습니다. 해결 방법으로는 toxiclib의 Octree예제를 살펴보시기 바랍니다.

- 크기의 제곱(또는 길이의 제곱)에서 제곱근을 빼고 연산하면 코드의 속도를 빠르게 만들 수 있습니다. 한두개가 아니라 몇천개라면 속도가 향상됨을 느낄 수 있습니다.
- 사인과 코사인 룩업 테이블. 일반적으로 제곱근, 사인, 코사인, 탄젠트 등의 함수는 계산하는 데 시간이 걸리는 함수 입니다. 매번 호출해서 계산하기 보다는 사인, 코사인의 0부터 TWO_PI까지의 값을 계산한 배열을 만들고 값을 저장해서 필요할 때 마다 꺼내어 사용하면 됩니다.
- 불필요한 PVector객체 생성를 막아야 합니다. 예를 들어 mouse위치를 가져오는 벡터를 for문안에 사용하는 것을 피해야 하고, 바로 연산이 가능한 벡터를 따로 변수로 만드는 것을 줄여야 합니다.








