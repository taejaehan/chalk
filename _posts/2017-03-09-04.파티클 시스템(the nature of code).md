---
layout: post
title: "04. 파티클 시스템 (The nature of code)"
description: "ArrayList, 클래스/상속/다형성/캡슐화, Javascript 상속/prototype"
tags: [n-code, development, javascript]
published: false
---

## Javascript 상속

- Javascript는 java처럼 class기반의 언어가 아니다.
- 대신 모든 오브젝트는 다른 오브젝트를 가리키는 prototype이라는 내부링크를 가지고 있다. 
- 이를 프로토타입 체인이라 부르며 마지막 오브젝의 prototype은 null을 가리킨다.
- 이 prototype을 사용하여 원형 오브젝트의 코드를 상속받아 재사용 할 수 있다.

function book(){} 

이라고 book함수가 정의되면 자동으로 book함수의 prototpye객체가 만들어지고 
book함수의 prototype속성은 새롭게 만들어진 prototype객체를 가리킨다.
prototype객체의 constructor속성은 A함수를 가리킨다.

book.prototpye (book함수의 prototpye객체)
book.prototype.constructor (book함수)


var book1 = new book();

new연산자와 book함수를 통해 생성한 book1이라는 오브젝트는 book.prototpye 객체를 참조한다.
book1의 __proto__라는 숨은 속성은 book.prototpye객체를 가리킨다.
(book함수의 prototpye은 new book(); 를 통해 생성하는 모든 오브젝트의 원형이 된다.)

book.prototype.getTitle = function(){
	return 'bible'
}

book의 prototype에 getTitle이라는 함수를 추가하면 

console.log(book1.getTitle())


book함수를 통해 생성된 모든 오브젝트들은 book함수의 
prototpye에 대한 숨은 링크를 가지므로 
해당 prototpye에 접근하여 사용할 수 있다.

따라서 book의 prototpye에 정의된 코드를 재사용 할 수 있고 객체 지향적인 프로그래밍이 가능해진다.

프로토타입을 이용하여 코드를 재사용하는 방법은 
위에 처럼 new 연산자를 사용하는 방법과
Object.create()를 사용하는 방법이 있다.

(Object.create()이 현재 권장되고 있고 이미 많이 사용하고있지만, 현재 성능상으로는 new를 사용하는 방법이 더 빠르고 구조가 복잡해지지 않는다면 별 문제가 없을 것이다. 따라서 이번 글에는 new를 이용한 방법만 쓰려고 한다.)


## Apply, Call

function book(title, author){
	console.log(title);
	console.log(author);
}

function bibleBook(name, price) {
	//fun.call(thisArg[, arg1[, arg2[, ...]]])
	//book.call(this, name, price);
	
	//fun.apply(thisArg[, argsArray])
	book.apply(this, [name, price]);
}

var bible = new bibleBook('성경','15000');





